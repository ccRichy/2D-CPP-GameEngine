#todo, elaborate this more but just start with some obvious stuff



1. The program compiles 2 cpp files for the platform/application layers respectively. Each platform is compiled distinctly, separated by their respective 'main' files. I also use a 0 Header-Guard, Unity-Build method for keep #includes, compile times to a minimum. See below for elaboration.

2. Another philosophy of the program is single source of truth wherever can be reasonable/possible. A number of structs have default values at declaration to avoid separation.

3. Everything that needs to be compiled for both the platform and the game should be included in "game.h" (real generic stuff like math, arrays, strings, etc)

4. This project considers .cpp files to be any files with implementation details. This does not rule out the file containing definitions. The project uses plently that contain both for "find" (Ctrl + F) purposes, and to keep our compilation time down. Rule of thumb, if it's going to include a function body, then make it a .cpp file







#Unity Build?
The most standard way, which is also the language design INTENDED way to compile a c/cpp program, is to expose the compiler to the various code directories, and have it automatically step through and compile each compilation unit as an object file. All files are loaded, compiled, and linked separately. Sounds good enough right now! 
As the programmer, it is intended for you to include headers as needed, per source file, to access definitions stored within. This is seen as efficient because they only contain the definitions/declaration etc. (well ya know.. if youre being a true full stack developer!).

That axis of efficiency, their lack of implementation code, pales in comparison to the overhead of reading the disk at compile time. Every time you create a new source file, 2 new disk-reads at compilation. (creating and linking object files). Every time you #include something in the source code, another disk-read. This is without fail, the #1 cause of compile time overhead.

YOU: Ok smart guy, if I cant #include, how the hell do I get the header data where it needs to go?

Do this instead: 
#include all source code in main or otherwise an 'include' file, at the earliest point possible in the program, and keep includes local. By doing this, all of those definitions will exist in the global namespace.

YOU: How horrible! Think of the namespace!
ME: No. But you can think about it! Im using words like 'earliest', and 'possible', because this system is not strict about implementation. Compiling more than one file is fine. If you MUST avoid a namespace conflict, just use a separate compilation unit for THAT data. You will still have many of the benefits of this technique.

YOU: But doesn't this create extra overhead on the developer to sort out the build?
ME: Yes! How much extra is proportional to how willing you are to dedicate to this system. Like I said, I make no guarantees that this system will fit snuggly within your current one. Ans just because you want to use a bad system, doesn't negate the quality of this one.


#0 Header Guard?
This is the secret sauce. Once you get an include down to a single location, you can safely remove the header gaurd! By definition, having 1 source means youre never redefining. And by leaving out the header guard, you actually make the compiler tell you if you ever make the mistake of including it again somewhere else!


#Why might you NOT want this.
====
1.) Global namespace. You can still declare global variables and such the same way, but global or not, they will simply always be global to any code below it. 
1a) In turn, "using enum (enumClassName)", is also no longer per-compilation unit if used in the file's global space.
3.) if youre in a system that it just wouldnt really meld with. you gotta make that call yourself


Don't listen to me, listen to the numbers, and most importantly:
Never let someone talk you out of your precious time!!
"normal comp times are good enough"
You can be content with your minutes of comp, doesnt mean I have to.
"this isnt true"
Ok



So if you wanna DO it yourself! :) Read here vv
WARNING: I do not guarantee your project will be in any condition to simply crowbar my system into your systems. Thats not my problem, you figure it out.
